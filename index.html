<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ãƒ•ãƒ­ãƒ¼ãƒãƒ£ãƒ¼ãƒˆä½œæˆãƒ„ãƒ¼ãƒ«</title>
  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      background-color: #fdfdfd;
    }

    #toolbar {
      padding: 10px;
      background: #eee;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    #toolbar button {
      background-color: #f48fb1;
      border: none;
      border-radius: 8px;
      padding: 6px 12px;
      color: white;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
      transition: 0.2s;
    }

    #toolbar button:hover {
      background-color: #ec407a;
    }

    #edit-toolbar {
      padding: 5px;
      background: #ddd;
      display: none;
      align-items: center;
      gap: 10px;
    }

    #canvas {
      position: relative;
      width: 100vw;
      height: calc(100vh - 80px);
      background: white; /* â† ã“ã“ã‚’ç™½ã« */
      overflow: hidden;
    }
.node {
  position: absolute;
  padding: 10px;
  background: white;
  border: 2px solid black;
  border-radius: 0px; /* â† è§’ä¸¸ã‚’å‰Šé™¤ */
  cursor: move;
  min-width: 100px;
  text-align: center;
  user-select: none;
  color: black;
  box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
}
.circle {
  width: 100px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 10px;
  background: white;
  border: 2px solid black;
  color: black;
  box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);

  /* æ¥•å††å½¢ */
  border-radius: 50% / 50%;
}




    .decision {
      width: 100px;
      height: 100px;
      background: white;
      border: 2px solid black; /* â† é»’ã®ç ´ç·šã« */
      transform: rotate(45deg);
      display: flex;
      align-items: center;
      justify-content: center;
      color: black;
    }

    .decision span {
      transform: rotate(-45deg);
      text-align: center;
      width: 100px;
      white-space: pre-wrap;
      user-select: none;
      color: inherit;
    }


    svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    marker {
      fill: black;
    }

    line, polyline {
      stroke: black;
      stroke-width: 2;
      fill: none;
      marker-end: url(#arrow);
      cursor: pointer;
    }

    .connection-label {
      font-size: 12px;
      fill: black;
      pointer-events: none;
      user-select: none;
    }

    #edit-toolbar input,
    #edit-toolbar button {
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button onclick="addNode('process')">å‡¦ç†ãƒãƒ¼ãƒ‰ã‚’è¿½åŠ </button>
    <button onclick="addNode('circle')">ä¸¸å‹å‡¦ç†ãƒãƒ¼ãƒ‰ã‚’è¿½åŠ </button>
    <button onclick="addNode('decision')">æ¡ä»¶åˆ†å²ãƒãƒ¼ãƒ‰ã‚’è¿½åŠ </button>
    <button onclick="exportImage()">ç”»åƒã¨ã—ã¦ä¿å­˜</button>
    <button onclick="undo()">Undo</button>
    <button onclick="redo()">Redo</button>
     <a href="https://xauusdformom.github.io/draw/" target="_blank">
    <button>PNGæç”»ã‚µã‚¤ãƒˆã¯ã“ã¡ã‚‰</button>
  </a>
  </div>

  <div id="edit-toolbar">
    <input id="edit-input" type="text" placeholder="ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›" />
    <input id="bgcolor-input" type="color" title="èƒŒæ™¯è‰²ã‚’å¤‰æ›´" />
    <input id="fontcolor-input" type="color" title="æ–‡å­—è‰²ã‚’å¤‰æ›´" />
    <button onclick="updateNode()">å¤‰æ›´</button>
    <button onclick="deleteNode()">ğŸ—‘ï¸ãƒãƒ¼ãƒ‰å‰Šé™¤</button>
    <input id="conn-label-input" type="text" placeholder="æ¥ç¶šãƒ©ãƒ™ãƒ«" style="display:none;" />
    <button id="conn-label-update-btn" style="display:none;" onclick="updateConnectionLabel()">æ¥ç¶šãƒ©ãƒ™ãƒ«å¤‰æ›´</button>
  </div>

  <div id="canvas">
    <svg id="lines">
     <defs>
  <marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="5"
          orient="auto" markerUnits="strokeWidth">
    <path d="M0,0 L0,10 L10,5 z" fill="black" />
  </marker>
</defs>

    </svg>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script>
    let selectedNode = null;
    let connections = [];
    let selectedConnection = null;
    let history = [];
    let redoStack = [];

    function saveHistory() {
      history.push(JSON.stringify({
        nodes: [...document.querySelectorAll('.node')].map(node => ({
          left: node.style.left,
          top: node.style.top,
          text: node.classList.contains('decision') ? node.querySelector('span').textContent : node.textContent,
          type: node.classList.contains('decision') ? 'decision' : 'process',
          bgcolor: node.style.backgroundColor || '',
          fontcolor: node.style.color || ''
        })),
        connections: connections.map(c => ({
          fromIndex: [...document.querySelectorAll('.node')].indexOf(c.from),
          toIndex: [...document.querySelectorAll('.node')].indexOf(c.to),
          label: c.label || ''
        }))
      }));
      redoStack = [];
    }

    function undo() {
      if (history.length < 2) return;
      redoStack.push(history.pop());
      restoreHistory(history[history.length - 1]);
    }

    function redo() {
      if (redoStack.length === 0) return;
      const next = redoStack.pop();
      history.push(next);
      restoreHistory(next);
    }

    function restoreHistory(snapshot) {
      const data = JSON.parse(snapshot);
      document.querySelectorAll('.node').forEach(n => n.remove());
      connections = [];
      data.nodes.forEach(nodeData => {
        const node = document.createElement('div');
        node.className = 'node ' + nodeData.type;
        node.style.left = nodeData.left;
        node.style.top = nodeData.top;
        node.style.backgroundColor = nodeData.bgcolor || '';
        node.style.color = nodeData.fontcolor || 'black';
        if (nodeData.type === 'decision') {
          const span = document.createElement('span');
          span.textContent = nodeData.text;
          node.appendChild(span);
        } else {
          node.textContent = nodeData.text;
        }
        node.addEventListener('click', (e) => {
          e.stopPropagation();
          selectNode(node);
        });
        makeDraggable(node);
        document.getElementById('canvas').appendChild(node);
      });
      data.connections.forEach(c => {
        const from = document.querySelectorAll('.node')[c.fromIndex];
        const to = document.querySelectorAll('.node')[c.toIndex];
        if (from && to) connections.push({ from, to, label: c.label });
      });
      drawConnections();
    }
function addNode(type) {
  const node = document.createElement('div');
  node.className = 'node ' + type;
  node.style.left = '100px';
  node.style.top = '100px';
  node.style.color = 'black';

  if (type === 'decision') {
    const span = document.createElement('span');
    span.textContent = 'æ¡ä»¶?';
    node.appendChild(span);
  } else {
    node.textContent = 'å‡¦ç†';
  }

  node.addEventListener('click', (e) => {
    e.stopPropagation();
    selectNode(node);
  });
  makeDraggable(node);
  document.getElementById('canvas').appendChild(node);
  saveHistory();
}


    function makeDraggable(el) {
      let offsetX, offsetY;
      el.onmousedown = function(e) {
        offsetX = e.offsetX;
        offsetY = e.offsetY;
        function move(e) {
          el.style.left = `${e.pageX - offsetX}px`;
          el.style.top = `${e.pageY - offsetY}px`;
          drawConnections();
        }
        function up() {
          document.removeEventListener('mousemove', move);
          document.removeEventListener('mouseup', up);
          saveHistory();
        }
        document.addEventListener('mousemove', move);
        document.addEventListener('mouseup', up);
      }
    }

    function selectNode(node) {
      selectedNode = node;
      selectedConnection = null;
      const toolbar = document.getElementById('edit-toolbar');
      toolbar.style.display = 'flex';

      // ãƒãƒ¼ãƒ‰ãƒ†ã‚­ã‚¹ãƒˆç·¨é›†ç”¨
      const input = document.getElementById('edit-input');
      input.style.display = 'inline-block';
      if (node.classList.contains('decision')) {
        input.value = node.querySelector('span').textContent;
      } else {
        input.value = node.textContent;
      }

      // èƒŒæ™¯è‰²å…¥åŠ›æ¬„ã‚’è¡¨ç¤ºãƒ»è¨­å®š
      const bgcolorInput = document.getElementById('bgcolor-input');
      bgcolorInput.style.display = 'inline-block';
      bgcolorInput.value = rgbToHex(node.style.backgroundColor) || '#ffffff';

      // æ–‡å­—è‰²å…¥åŠ›æ¬„ã‚’è¡¨ç¤ºãƒ»è¨­å®š
      const fontcolorInput = document.getElementById('fontcolor-input');
      fontcolorInput.style.display = 'inline-block';
      fontcolorInput.value = rgbToHex(node.style.color) || '#000000';

      // æ¥ç¶šãƒ©ãƒ™ãƒ«å…¥åŠ›æ¬„ã¯éš ã™
      document.getElementById('conn-label-input').style.display = 'none';
      document.getElementById('conn-label-update-btn').style.display = 'none';
    }

    function updateNode() {
      if (!selectedNode) return;
      const input = document.getElementById('edit-input');
      if (selectedNode.classList.contains('decision')) {
        selectedNode.querySelector('span').textContent = input.value;
      } else {
        selectedNode.textContent = input.value;
      }
      const bgcolorInput = document.getElementById('bgcolor-input');
      selectedNode.style.backgroundColor = bgcolorInput.value;
      const fontcolorInput = document.getElementById('fontcolor-input');
      selectedNode.style.color = fontcolorInput.value;
      saveHistory();
    }

    function deleteNode() {
      if (selectedNode) {
        connections = connections.filter(c => c.from !== selectedNode && c.to !== selectedNode);
        selectedNode.remove();
        selectedNode = null;
        document.getElementById('edit-toolbar').style.display = 'none';
        drawConnections();
        saveHistory();
      }
    }

    // ä»¥ä¸‹ã€æ¥ç¶šé–¢ä¿‚ã®æ“ä½œï¼ˆæ¥ç¶šãƒ©ãƒ™ãƒ«ã®ç·¨é›†ç­‰ï¼‰ã¯ãã®ã¾ã¾ç¶­æŒ

    function selectConnection(index) {
      selectedConnection = index;
      selectedNode = null;
      const toolbar = document.getElementById('edit-toolbar');
      toolbar.style.display = 'flex';

      // æ¥ç¶šãƒ©ãƒ™ãƒ«ç·¨é›†ç”¨å…¥åŠ›æ¬„è¡¨ç¤º
      const connLabelInput = document.getElementById('conn-label-input');
      const connLabelBtn = document.getElementById('conn-label-update-btn');
      connLabelInput.style.display = 'inline-block';
      connLabelBtn.style.display = 'inline-block';
      connLabelInput.value = connections[index].label || '';

      // ãƒãƒ¼ãƒ‰ç·¨é›†ç”¨ã®ãƒ†ã‚­ã‚¹ãƒˆãƒ»è‰²å…¥åŠ›ã¯éè¡¨ç¤º
      document.getElementById('edit-input').style.display = 'none';
      document.getElementById('bgcolor-input').style.display = 'none';
      document.getElementById('fontcolor-input').style.display = 'none';
    }

    function updateConnectionLabel() {
      if (selectedConnection === null) return;
      const input = document.getElementById('conn-label-input');
      connections[selectedConnection].label = input.value;
      drawConnections();
      saveHistory();
    }

    // å‰Šé™¤ãƒœã‚¿ãƒ³ã¯æ¶ˆã—ãŸã®ã§ã“ã®é–¢æ•°ã¯æ®‹ã—ã¾ã™ãŒç·¨é›†ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‹ã‚‰ã®å‘¼ã³å‡ºã—ã¯ãªã—

function drawConnections() {
  const svg = document.getElementById('lines');
  svg.innerHTML = svg.innerHTML.split('</defs>')[0] + '</defs>';
  connections.forEach(({ from, to, label }, index) => {
    const fromRect = from.getBoundingClientRect();
    const toRect = to.getBoundingClientRect();
    const canvasRect = document.getElementById('canvas').getBoundingClientRect();

    const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
    const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;

    // toãƒãƒ¼ãƒ‰ã®ä¸­å¤®xåº§æ¨™ï¼ˆæ¨ªè»¸æŠ˜ã‚Œãƒã‚¤ãƒ³ãƒˆï¼‰
    const x2_center = toRect.left + toRect.width / 2 - canvasRect.left;

    // toãƒãƒ¼ãƒ‰ã®ä¸Šè¾ºyåº§æ¨™ï¼ˆç¸¦æŠ˜ã‚Œãƒã‚¤ãƒ³ãƒˆå…¼ç·šã®çµ‚ç‚¹ï¼‰
    const y2 = toRect.top - canvasRect.top;

    // æŠ˜ã‚Œç·šã®ãƒã‚¤ãƒ³ãƒˆï¼ˆ3ç‚¹æŠ˜ã‚Œï¼‰
    const points = [
      `${x1},${y1}`,        // fromã®ä¸­å¿ƒ
      `${x2_center},${y1}`, // æ¨ªã¯toã®ä¸­å¤®ã€ç¸¦ã¯fromã®yï¼ˆæŠ˜ã‚Œï¼‰
      `${x2_center},${y2}`, // æ¨ªã¯toã®ä¸­å¤®ã€ç¸¦ã¯toã®ä¸Šè¾º
    ].join(' ');

    const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
    polyline.setAttribute("points", points);
    polyline.setAttribute('data-index', index);
    polyline.setAttribute("marker-end", "url(#arrow)");
    polyline.style.cursor = 'pointer';
    polyline.addEventListener('click', (e) => {
      e.stopPropagation();
      selectConnection(index);
    });
    svg.appendChild(polyline);

    if (label) {
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      // ãƒ©ãƒ™ãƒ«ã¯æŠ˜ã‚Œç·šã®æŠ˜ã‚Œç‚¹ã®å°‘ã—å³ä¸Šã‚ãŸã‚Šã«è¡¨ç¤ºï¼ˆä»»æ„èª¿æ•´å¯ï¼‰
      text.setAttribute("x", x2_center + 5);
      text.setAttribute("y", (y1 + y2) / 2 - 5);
      text.setAttribute("class", "connection-label");
      text.textContent = label;
      svg.appendChild(text);
    }
  });
}



    document.getElementById('canvas').addEventListener('click', () => {
      selectedNode = null;
      selectedConnection = null;
      document.getElementById('edit-toolbar').style.display = 'none';
    });

    // ãƒãƒ¼ãƒ‰é–“ã®æ¥ç¶šï¼ˆå³ã‚¯ãƒªãƒƒã‚¯ã§æ¥ç¶šä½œæˆï¼‰ã¯ãã®ã¾ã¾

    document.getElementById('canvas').addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const nodes = document.elementsFromPoint(e.clientX, e.clientY).filter(el => el.classList.contains('node'));
      if (nodes.length === 1 && selectedNode && selectedNode !== nodes[0]) {
        const label = prompt("æ¥ç¶šãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›ï¼ˆä»»æ„ï¼‰ï¼š", "");
        connections.push({ from: selectedNode, to: nodes[0], label });
        drawConnections();
        saveHistory();
      }
    });

    // è‡ªå‹•æ•´åˆ—é–¢æ•°ã¯å‰Šé™¤ã—ã¾ã—ãŸ

    // ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼šrgbã‚’16é€²æ•°ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã«å¤‰æ›
    function rgbToHex(rgb) {
      if (!rgb) return '';
      const result = /^rgba?\((\d+),\s*(\d+),\s*(\d+)/i.exec(rgb);
      if (!result) return '';
      return "#" + [1,2,3].map(i => {
        const hex = parseInt(result[i]).toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      }).join('');
    }

    function exportImage() {
  const canvasElement = document.getElementById('canvas');
  html2canvas(canvasElement).then(canvas => {
    const link = document.createElement('a');
    link.download = 'flowchart.png'; // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«å
    link.href = canvas.toDataURL('image/png'); // ç”»åƒã®URL
    link.click(); // è‡ªå‹•çš„ã«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’é–‹å§‹
  });
}

  </script>
</body>
</html>